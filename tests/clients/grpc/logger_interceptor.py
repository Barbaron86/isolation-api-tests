from logging import Logger

from grpc import UnaryUnaryClientInterceptor


class GRPCLoggerInterceptor(UnaryUnaryClientInterceptor):
    """
    Инфраструктурный interceptor gRPC-клиента тестового слоя.

    Задача interceptor'а — фиксировать факт gRPC-взаимодействия
    на уровне транспорта, а не на уровне бизнес-логики.

    Почему это важно в контексте тестов:
    - при падении интеграционного теста лог gRPC-вызовов — первое,
      что позволяет понять, "куда мы сходили" и "на каком вызове упали";
    - логирование должно быть централизованным и одинаковым
      для всех gRPC-клиентов, а не реализованным вручную в каждом методе;
    - interceptor — это стандартный механизм gRPC для таких задач.

    Границы ответственности:
    interceptor НЕ знает:
    - какой тест выполняется,
    - какой сервис вызывается (он видит только имя метода),
    - какие доменные данные передаются,
    - какие схемы ответов ожидаются.

    Он знает только одно:
    "выполнен gRPC-вызов метода <method>".
    """

    def __init__(self, logger: Logger):
        # Логгер передаётся извне, чтобы:
        # - не хардкодить источник логов и конфигурацию логирования,
        # - использовать единый логгер тестового слоя,
        # - управлять форматами/уровнями логов централизованно.
        self.logger = logger

    def intercept_unary_unary(self, continuation, client_call_details, request):
        # Этот interceptor покрывает unary-unary вызовы:
        # один запрос -> один ответ.
        #
        # На уровне курса это базовый случай и основа,
        # на которую дальше можно наращивать поддержку:
        # - unary-stream
        # - stream-unary
        # - stream-stream
        #
        # Но мы начинаем с минимального, инженерно достаточного ядра.

        # В client_call_details.method лежит строка с полным путём метода,
        # например: "/package.Service/Method".
        #
        # Это не "бизнес-метод", а транспортная идентичность вызова.
        self.logger.info(f"REQUEST: {client_call_details.method}")

        # continuation — это "следующий шаг" в цепочке вызова:
        # либо реальный вызов в сеть, либо следующий interceptor.
        response = continuation(client_call_details, request)

        # После выполнения вызова фиксируем, что ответ получен.
        #
        # Важно: здесь мы не читаем body ответа и не логируем payload.
        # В реальных системах payload может содержать чувствительные данные,
        # а в тестовом проекте лишний шум в логах снижает диагностическую ценность.
        self.logger.info(f"RESPONSE: {client_call_details.method}")

        return response
